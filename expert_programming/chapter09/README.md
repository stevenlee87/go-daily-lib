# Chapter 9 定时器

定时器在Go语言应用中使用非常广泛，准确掌握其用法和实现原理至关重要。  
Go提供了两种定时器，此处分为一次性定时器、周期性定时器。  
- 一次性定时器：定时器只计时一次，结束便停止； 
- 周期性定时器：定时器周期性进行计时，除非主动停止，否则将永久运行；  

本章会快速介绍这两种定时器的基本用法，重点介绍其内部实现原理，最后再给出一个案例揭示使用定时器的风险。

## 9.1 一次性定时器（Timer）

### 9.1.1 快速开始

1. 简介  

2. 使用场景  
1). 设定超时时间  
2). 延迟执行某个方法

3. Timer对外接口  
1). 创建定时器  
2). 停止定时器  
3). 重置定时器

4. 简单接口  
1). After()  
2). AfterFunc()

5. 小结  
Timer内容总结如下：
   - time.NewTimer(d)创建一个Timer; 
   - timer.Stop()停掉当前Timer; 
   - timer.Reset(d)重置当前Timer;

### 9.1.2 实现原理

很多人想当然的以为，启动一个Timer意味着启动了一个协程，这个协程会等待Timer到期，
然后向Timer的管道中 发送当前时间。 

实际上，每个Go应用程序都有一个协程专门负责管理所有的Timer，这个协程负责监控Timer是否过期，
过期后执行一个预定义的动作， 这个动作对于Timer而言就是发送当前时间到管道中。

1. 数据结构  
1). Timer  
源码包 src/time/sleep.go:Timer 定义了其数据结构：  
```text
type Timer struct {
   C <-chan Time
   r runtimeTimer
}
```  

2). runtimeTimer  

2. 实现原理  

一个进程中的多个Timer都由底层的一个协程来管理，为了描述方便我们把这个协程称为系统协程。 

我们想在后面的章节中单独介绍系统协程工作机制，本节，我们先简单介绍其工作过程。 

系统协程把runtimeTimer存放在数组中，并按照 when 字段对所有的runtimeTimer进行堆排序，
定时器触发时执行runtimeTimer中的预定义函数 f ，即完成了一次定时任务。  

1). 创建Timer  
2). 停止Timer  
3). 重置Timer

3. 小结  
- NewTimer()创建一个新的Timer交给系统协程监控； 
- Stop()通知系统协程删除指定的Timer; 
- Reset()通知系统协程删除指定的Timer并再添加一个新的Timer；

## 9.2 周期性定时器(Ticker)

### 9.2.1 快速开始

1. 简介

Ticker是周期性定时器，即周期性的触发一个事件，通过Ticker本身提供的管道将事件传递出去。 

Ticker的数据结构与Timer完全一致： 

```text
type Ticker struct { 
    C <-chan Time
    r runtimeTimer
} 
```

Ticker对外仅暴露一个channel，指定的时间到来时就往该channel中写入系统时间，也即一个事件。 

在创建Ticker时会指定一个时间，作为事件触发的周期。这也是Ticker与Timer的最主要的区别。 

另外，ticker的英文原意是钟表的”滴哒”声，钟表周期性的产生”滴哒”声，也即周期性的产生事件。

2. 使用场景  
1). 简单定时任务  
2). 简单定时任务

3. Ticker对外接口

4. 简单接口

5. 错误示例

6. 小结

## 9.3 runtimeTimer

前面我们介绍了一次性定时器Timer和周期性定时器Ticker，这两种定时器内部实现机制完全相同。创建定时器的协 程并不负责计时，而是把任务交给系统协程，系统协程统一处理所有的定时器。 

本节，我们重点关注系统协程是如何管理这些定器的，包括以下问题： 
- 定时器使用什么数据结构存储？ 
- 定时器如何触发事件？ 
- 定时器如何添加进系统协程？ 
- 定时器如何从系统协程中删除？

### 9.4 案例分享

前面我们讨论了如果定时器使用不当会有资源泄露的风险，使用时需要格外注意。 

实际项目中发生Ticker资源泄露的场景有如下几种： 
1. 创建了Ticker，忘记在使用结束后Stop； 
2. 从别处拷贝代码未拷贝Stop语句； 
3. 开源或第三方库中发生泄露； 

对于前两种，推荐创建Ticker后立即使用defer语句将Ticker停掉，比如类似下面的代码：
```text
ticker := time.NewTicker(1 * time.Second) 
defer ticker.Stop()
```

使用defer是安全的，因为只有当函数退出时才会执行，上面两行代码甚至可以写到一行中。 
经常使用开源或第三方库时难免会遇到资源泄露的问题，这时我们就需要掌握一些基本的定位手段，
接下来分享一个自己在做项目遇到的开源库资源泄露的案例。
案例中使用的pprof工具，本处只做简单说明，详细的使用方法请参考 相关章节。

1.应用背景

曾经做过一个产品，不经意间出现了CPU使用率缓慢升高，最后CPU使用率竟然达到了100%，
严重影响了业务。经过 排查，问题出在Ticker的使用方式上，创建了Ticker，在使用结束后没有释放导致的。 

该产品需要监控其他服务器的健康状态，其中很常见的一种做法是心跳检测。简单的说，
周期性的ping这些服务器， 能在指定时间内收到ack说明与该服务器之间的网络没问题。 

当时使用了一个小众的开源组件 tatsushid/go-fastping 来做ping。
https://github.com/tatsushid/go-fastping

2.问题现象

3.源码分析

4.小结

有一种情况使用Ticker不主动关闭也不会造成资源泄露，比如，函数创建Ticker后就不会退出，
直到进程结束。这 种情况下不会持续的创建Ticker，也就不会造成资源泄露。 

但是，不管哪种情况，创建一个Ticker后，紧跟着使用defer语句关闭Ticker总是好的习惯。
因为，有可能别人无意间拷贝了你的部分代码，而忽略了关闭Ticker的动作。