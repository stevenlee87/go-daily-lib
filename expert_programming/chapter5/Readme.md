## Chapter 5 并发控制

本章主要介绍GO语言开发过程中经常使用的并发控制手段。

我们考虑这么一种场景，协程A执行过程中需要创建子协程A1、A2、A3…An，协程A创建完子协程后就等待子协程退出。
针对这种场景，GO提供了三种解决方案：
Channel: 使用channel控制子协程
WaitGroup : 使用信号量机制控制子协程
Context: 使用上下文控制子协程

三种方案各有优劣，比如Channel优点是实现简单，清晰易懂，WaitGroup优点是子协程个数动态可调整，Context

优点是对子协程派生出来的孙子协程的控制。缺点是相对而言的，要结合实例应用场景进行选择。 

## 5.3 Context
Golang context是Golang应用开发常用的并发控制技术，它与WaitGroup最大的不同点是context对于派生 goroutine有更强的控制力，
它可以控制多级的goroutine。 context翻译成中文是”上下文”，即它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。
典型的使用场景如下图所示：
![avatar](https://github.com/stevenlee87/go-daily-lib/blob/main/expert_programming/chapter5/5.3_context/context.png)

## 总结
- Context仅仅是一个接口定义，跟据实现的不同，可以衍生出不同的context类型；
- cancelCtx实现了Context接口，通过WithCancel()创建cancelCtx实例；
- timerCtx实现了Context接口，通过WithDeadline()和WithTimeout()创建timerCtx实例；
- valueCtx实现了Context接口，通过WithValue()创建valueCtx实例；
- 三种context实例可互为父节点，从而可以组合成不同的应用形式； 

## 5.4 Mutex
互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，
对外暴露Lock(),Unlock()两个方法，分别用于加锁和解锁。

变成Tips  
1) 使用defer避免死锁  
  加锁后立即使用defer对其解锁，可以有效地避免死锁
2) 加锁和解锁应该成对出现
  加锁和解锁最好出现在同一个层次的代码块中，比如同一个函数。重复解锁会触发panic，应避免这种操作的可能性。

## 5.5 RWmutex

前面我们分析了互斥锁Mutex，所谓读写锁RWMutex，完整的表述应该是读写互斥锁，可以说是Mutex的一个改进版，在某些场景下可以发挥更加灵活的控制
能力，不如读取数据频率远大于写数据频率的场景。

例如，程序操作中写操作少而读操作多，简单地说，如果执行过程是1次写然后N次读，则使用Mutex，这个过程将是串行的，因为即便互相之间并不影响，但也都
需要持有Mutex后才可以操作。如果使用读写锁，那么多个读操作可以同时持有锁，并发能力将大大提升。
- 写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；
- 写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；
- 读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；
- 读锁不能阻塞读锁：一个协程拥有读锁时，其他协程可以拥有读锁；

### 自旋过程
加锁时，如果当前Locked位为1，则说明当前该锁由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续地探测Locked位是否变为0，这个过程称为
自旋。  
自旋的时间很短，如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。  
自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。