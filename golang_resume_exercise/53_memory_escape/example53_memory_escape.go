package main

import "fmt"

type A struct {
	s string
}

// 这是上面提到的 "在方法内把局部变量指针返回" 的情况

func foo(s string) *A {
	a := new(A)
	a.s = s
	return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆

}
func main() {
	a := foo("hello")
	b := a.s + " world"
	c := b + "!"
	fmt.Println(c)
}

/*
go build -gcflags=-m example53_memory_escape.go
# command-line-arguments
./example53_memory_escape.go:11:6: can inline foo
./example53_memory_escape.go:18:10: inlining call to foo
./example53_memory_escape.go:21:13: inlining call to fmt.Println
./example53_memory_escape.go:11:10: leaking param: s
./example53_memory_escape.go:12:10: new(A) escapes to heap
./example53_memory_escape.go:18:10: new(A) does not escape
./example53_memory_escape.go:19:11: a.s + " world" does not escape
./example53_memory_escape.go:20:9: b + "!" escapes to heap
./example53_memory_escape.go:21:13: c escapes to heap
./example53_memory_escape.go:21:13: []interface {}{...} does not escape
<autogenerated>:1: .this does not escape
*/

/*
问题:
知道golang的内存逃逸吗？什么情况下会发⽣内存逃逸？
回答:
golang程序变量会携带有⼀组校验数据，⽤来证明它的整个⽣命周期是否在运⾏时完全
可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

能引起变量逃逸到堆上的典型情况：
  1.在⽅法内把局部变量指针返回局部变量原本应该在栈中分配，在栈中回收。但是由
于返回时被外部引⽤，因此其⽣命周期⼤于栈，则溢出。
  2.发送指针或带有指针的值到 channel 中。在编译时，是没有办法知道哪个 goroutine 会 channel 上接收数据。
所以编译器没法知道变量什么时候才会被释放。
  3.在⼀个切⽚上存储指针或带指针的值。⼀个典型的例⼦就是 []*string 。这会导致切⽚的内容逃逸。
尽管其后⾯的数组可能是在栈上分配的，但其引⽤的值⼀定是在堆上。
  4.slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。slice初始化的地⽅在编译时是可以知道的，
它最开始会在栈上分配。如果切⽚背后的存储要基于运⾏时的数据进⾏扩充，就会在堆上分配。
  5.在 interface 类型上调⽤⽅法。在 interface 类型上调⽤⽅法都是动态调度的 ——⽅法的真正实现只能在运⾏时知道。
想像⼀个 io.Reader 类型的变量 r , 调⽤r.Read(b) 会使得 r 的值和切⽚b 的背后存储都逃逸掉，所以会在堆上分配。
*/
